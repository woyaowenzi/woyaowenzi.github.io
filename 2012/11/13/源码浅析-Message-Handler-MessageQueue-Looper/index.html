<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>源码浅析: Message/Handler/MessageQueue/Looper | WOYAOWENZI&#39;s blog</title>
  <meta name="author" content="LiuLin">
  
  <meta name="description" content="项目终于没那么忙了！闲下来几天，想想应该学点什么，总结点什么。总体上来，要学的东西实在太多了，看了看自己写的代码，结果发现连最基本的消息机制都没有了解清楚，虽然一直在用Handler发消息（Message），但一直没有去探究它们内部是如何运作的。于是花了一天的时间仔细分析了一下几个基本类的源码，略有所悟，浅析一下。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="源码浅析: Message/Handler/MessageQueue/Looper"/>
  <meta property="og:site_name" content="WOYAOWENZI&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <!-- <link href="/favicon.png" rel="icon"> -->
  <!-- <link href="favicon.ico" rel="shortcut icon" type="image/x-icon" /> -->
  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="alternate" href="/atom.xml" title="WOYAOWENZI&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">WOYAOWENZI&#39;s blog</a></h1>
  <h2><a href="/">玉不琢，不成器。人不俗，没有趣！</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">存档</a></li>
    
      <li><a href="/">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-11-12T16:40:56.000Z"><a href="/2012/11/13/源码浅析-Message-Handler-MessageQueue-Looper/">11月 13 2012</a></time>
      
      
  
    <h1 class="title">源码浅析: Message/Handler/MessageQueue/Looper</h1>
  

    </header>
    <div class="entry">
      
        <p>项目终于没那么忙了！闲下来几天，想想应该学点什么，总结点什么。总体上来，要学的东西实在太多了，看了看自己写的代码，结果发现连最基本的消息机制都没有了解清楚，虽然一直在用Handler发消息（Message），但一直没有去探究它们内部是如何运作的。于是花了一天的时间仔细分析了一下几个基本类的源码，略有所悟，浅析一下。<br><a id="more"></a><br><strong>在探究源码之前，我觉得有必要有一个温习一下Windows的消息机制，以示对比。</strong><br><strong>以消息为基础，以事件驱动之（Messagebased, event driven）</strong><br>（注：以下部分摘自 侯捷——《深入浅出MFC》）</p>
<p>熟悉<strong>Win32/MFC</strong>编程的人都知道，Windows应用程序的都是<strong>以事件来驱动</strong>。换句话说，程序不断等待（利用一个while回路），等待任何可能的输入，然后做判断，然后再做适当的处理。这个「输入」就是以消息（Message）的形式表现出来的。这个过程可以用下图简单的表示。如果把应用程序获得的各种「输入」分类，可以分为由硬件装置所产生的消息（如鼠标移动或键盘被按下），放在系统队列（system queue）中，以及由Windows系统或其它Windows程序传送过来的消息，放在程序队列（application queue）中（在这个过程中，使用SendMessage(…)和PostMessage(…)这两个API来发送消息）。以应用程序的眼光来看，消息就是消息，来自哪里或放在哪里其实并没有太大区别，反正程序调用GetMessage API就取得一个消息，程序的生命靠它来推动。<br>可想而知，每一个Windows程序都应该有一个回路如下：</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>MSG msg;
<span class="keyword">while</span> (GetMessage(&msg, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>)) {
    TranslateMessage(&msg);
    DispatchMessage(&msg);
}
</pre></td></tr></table></figure>

<p>对于接受并处理消息的主角就是窗口。每一个窗口都应该有一个函数负责处理消息，程序员必须负责设计这个所谓的「窗口函数」（window procedure）。如果窗口获得一个消息，这个窗口函数必须判断消息的类别，决定处理的方式。</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>WndProc(hwnd, msg, wParam, lParam) {
    <span class="keyword">switch</span> (msg) {
        case WM_CREATE: <span class="keyword">...</span>// do something, <span class="keyword">break</span>
        case WM_COMMAND: <span class="keyword">...</span>
        case WM_LBUTTONDOWN: <span class="keyword">...</span>
        case WM_PAINT: <span class="keyword">...</span>
        case WM_CLOSE: <span class="keyword">...</span>
        case WM_DESTROY: <span class="keyword">...</span>
        default: <span class="keyword">return</span> DefWindowProc(<span class="keyword">...</span>);
    }
    <span class="keyword">return</span>(<span class="number">0</span>);
}
</pre></td></tr></table></figure>

<p>所以程序一旦运行起来，就会不停的：<strong>获取消息—&gt;分发消息—&gt;处理消息—&gt;获取消息—&gt;….</strong><br>消息从哪里来？嗯。上面提到过了，从消息队列（消息泵）里来。如果没有消息怎么办，那就在获取消息（GetMessage）的这个函数这里阻塞住，直到有新的消息发送到消息队列里。<br><img src="/image/source-analyze/windows-message-loop.png" alt="windows-message-loop"></p>
<p>如果你了解上面所描述的概念，再看Android的消息循环应该会发现真的很简单，只不过多了一些封装，多了一些类而已，整体思路都是大同小异的。</p>
<h2 id="相关概念">相关概念</h2>
<p>在看源码前，我们先需要熟悉一下它们的概念及作用。</p>
<ul>
<li><strong>Message：</strong>用于封装消息的简单数据结构。里面包含消息的ID、数据对象、处理消息的<code>Handler</code>引用和<code>Runnable</code>等。</li>
<li><strong>Handler：</strong>消息的发送者和最终消息处理者。</li>
<li><strong>MessageQueue：</strong>消息队列，提供消息的添加、删除、获取等操作来管理消息队列。</li>
<li><strong>Looper：</strong>用于建立消息循环并管理消息队列（<code>MessageQueue</code>），不停的从消息队列中抽取消息，分发下去并执行。</li>
</ul>
<p>注：以下分析均以 <strong>android 2.3.3</strong> 源码为基础。</p>
<h2 id="Message源码分析">Message源码分析</h2>
<h3 id="成员变量">成员变量</h3>
<p>我们先看一下它的成员变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> {</span>
    <span class="keyword">public</span> <span class="keyword">int</span> what;
    <span class="keyword">public</span> <span class="keyword">int</span> arg1; 
    <span class="keyword">public</span> <span class="keyword">int</span> arg2;
    <span class="keyword">public</span> Object obj;
    <span class="keyword">public</span> Messenger replyTo;
    <span class="comment">/*package*/</span> <span class="keyword">long</span> when;
    <span class="comment">/*package*/</span> Bundle data;
    <span class="comment">/*package*/</span> Handler target;     
    <span class="comment">/*package*/</span> Runnable callback;   
    <span class="comment">// sometimes we store linked lists of these things</span>
    <span class="comment">/*package*/</span> Message next;
    ......
}
</pre></td></tr></table></figure>

<p>简单参数就不需要解释了，重点在以下几个成员变量。</p>
<ul>
<li><strong>long when：</strong>该消息何时被处理的绝对时间戳。</li>
<li><strong>Handler target：</strong>谁来处理该消息。如果它为空，那说明该消息可能被recycle掉了，存放在Message Pool中，或者，它代表一个QUIT消息。</li>
<li><strong>Runnable callback：</strong>Runnable对象，如果为该Message设置了该对象，那么有优先执行它。这里需要看Handler的消息处理机制。在分析Handler时再提。</li>
<li><strong>Message next：</strong>这个看起来有点奇怪，有种似曾相识的感觉，想想，到底什么情况。哦，想起来了，就是C语言里面链表的数据结构。</li>
</ul>
<figure class="highlight C++"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="title">typedef</span> struct <span class="type">LNode</span>{
    <span class="type">ElemType</span> <span class="typedef"><span class="keyword">data</span>;</span>
    <span class="type">Struct</span> <span class="type">LNode</span>* next;
}
</pre></td></tr></table></figure>

<p>由于JAVA是没有指针这个概念的，所以内部维护了一个<strong>next的引用</strong>。所以，实际上，Message本身不单纯是一个简单的只包含数据的类，<strong>它实际上是一个链式结构的类，也就是说，一个Message本身就是一个消息队列，它通过next将所有消息串联起来。既然Message本身就是消息队列</strong>，那MessageQueue又是如何建立消息队列的又是怎么回事？实际上，MessageQueue内部只有一个Message成员，它所要做的工作就是把Message实体串连起来，形成消息链。<br>接着再看静态成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">private</span> <span class="keyword">static</span> Object mPoolSync = <span class="keyword">new</span> Object(); <span class="comment">// 用于访问mPool时进行同步操作</span>
<span class="keyword">private</span> <span class="keyword">static</span> Message mPool;                   <span class="comment">// 全局的废弃消息池（链）（就是废品收购站）</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> mPoolSize = <span class="number">0</span>;               <span class="comment">// 消息池当前大小</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;    <span class="comment">// 消息池上限值</span>
</pre></td></tr></table></figure>

<p>从这上面能看出，有个叫<code>mPool</code>的Message对象，如果理解了Message本身就是链表结构，那么，应该就明白了为什么一个消息叫Pool（池），因为一个Message本身就代表着一群Message，通过next把一系列Message给串联起来。对于无数个message实体来说，他们共享同一个全局的消息池（链），里面存放废弃掉的message。很明显，这是在做<code>缓存机制</code>。<br>在该类中，核心函数有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span>()及系列函数
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span>()
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendToTarget</span>()
</pre></td></tr></table></figure>

<h3 id="obtain()及其系列函数">obtain()及其系列函数</h3>
<p><strong>obtain()</strong>系列函数最核心的函数就只有obtain()方法，其它函数只不过提供了更多的可选参数，内部都是调用obtain()方法，因此，我们只需要关注核心函数的实现即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="javadoc">/**
 * Return a new Message instance from the global pool. Allows us to
 * avoid allocating new objects in many cases.
 */</span>
<span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span>() {
    <span class="keyword">synchronized</span> (mPoolSync) {
        <span class="keyword">if</span> (mPool != <span class="keyword">null</span>) {
            Message m = mPool;
            mPool = m.next;
            m.next = <span class="keyword">null</span>;
            <span class="keyword">return</span> m;
        }
    }
    <span class="keyword">return</span> <span class="keyword">new</span> Message();
}
</pre></td></tr></table></figure>

<p>该函数内部首先是从全局的废弃消息池（链）中去取，看看有没有废弃掉的Message，如果有，那我们就获取消息链中第一个废弃掉的Message，这样，就无需再创建一个新的Message；如果消息池中没有，那就只能new一个新的消息出来。这样做的好处就是废物再利用，减少创建时间。实际上，这种思想很值得我们借鉴。对于其它重载版的obtain方法，内部都是先调用它，然后再使用其它额外的参数进行填充的。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span>(Handler h, <span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, Object obj) {
    Message m = obtain();
    m.target = h;
    m.what = what;
    m.arg1 = arg1;
    m.arg2 = arg2;
    m.obj = obj;

    <span class="keyword">return</span> m;
}
</pre></td></tr></table></figure>

<h3 id="recycle()函数">recycle()函数</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="javadoc">/**
 * Return a Message instance to the global pool.  You MUST NOT touch
 * the Message after calling this function -- it has effectively been
 * freed.
 */</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span>() {
    <span class="keyword">synchronized</span> (mPoolSync) {
        <span class="keyword">if</span> (mPoolSize &lt; MAX_POOL_SIZE) {
            clearForRecycle();
            
            next = mPool;
            mPool = <span class="keyword">this</span>;
        }
    }
}
</pre></td></tr></table></figure>

<p>其中：clearForRecycle代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">/*package*/</span> <span class="keyword">void</span> clearForRecycle() {
    what = <span class="number">0</span>;
    arg1 = <span class="number">0</span>;
    arg2 = <span class="number">0</span>;
    obj = <span class="keyword">null</span>;
    replyTo = <span class="keyword">null</span>;
    when = <span class="number">0</span>;
    target = <span class="keyword">null</span>;
    callback = <span class="keyword">null</span>;
    data = <span class="keyword">null</span>;
}
</pre></td></tr></table></figure>

<p>这个函数首先是看当前消息池中废弃个数已达上限（池子是不是满了），如果没有达到上限，则调用<code>clearForRecycle()</code>函数把当前消息的各种信息清空，然后添加到消息链的头部。注意：该函数的<code>if (mPoolSize &lt; MAX_POOL_SIZE)</code>实际上是没有起到任何作用的，搜遍Message所有代码也没有发现<code>mPoolSize</code>的值有任何变化，始终为0，也就是说，这句话是恒成立的。<strong>只要该Message被recycle掉，那他就会加入到废弃链中</strong>。<br>可以用以下图示表示该过程：<br><img src="/image/source-analyze/android-message-chain.png" alt="android-message-chain"></p>
<p><strong>值得说明一点的是，该recycle()函数何时被调用？有以下两个时机被调用：</strong></p>
<ul>
<li>MessageQueue类中的removeMessages(…)及其系列函数，即当我们要从消息队列中干掉一个Message时，该Message被回收到废弃消息链。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="keyword">final</span> <span class="keyword">boolean</span> removeMessages(Handler h, <span class="keyword">int</span> what, Object object, <span class="keyword">boolean</span> doRemove) {  
    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {  
        Message p = mMessages;  
        <span class="keyword">boolean</span> found = <span class="keyword">false</span>;  
  
        <span class="comment">// Remove all messages at front.  </span>
        <span class="keyword">while</span> (p != <span class="keyword">null</span> && p.target == h && p.what == what  
               && (object == <span class="keyword">null</span> || p.obj == object)) {  
            <span class="keyword">if</span> (!doRemove) <span class="keyword">return</span> <span class="keyword">true</span>;  
            found = <span class="keyword">true</span>;  
            Message n = p.next;  
            mMessages = n;  
            p.recycle();  
            p = n;  
        }  
        <span class="comment">// Remove all messages after front </span>
        <span class="keyword">while</span> (p != <span class="keyword">null</span>) {  
            Message n = p.next;  
            <span class="keyword">if</span> (n != <span class="keyword">null</span>) {  
                <span class="keyword">if</span> (n.target == h && n.what == what  
                    && (object == <span class="keyword">null</span> || n.obj == object)) {  
                    <span class="keyword">if</span> (!doRemove) <span class="keyword">return</span> <span class="keyword">true</span>;  
                    found = <span class="keyword">true</span>;  
                    Message nn = n.next;  
                    n.recycle();  
                    p.next = nn;  
                    <span class="keyword">continue</span>;  
                }  
            }  
            p = n;  
        }  
          
        <span class="keyword">return</span> found;  
    }  
}
</pre></td></tr></table></figure>

<ul>
<li>Looper类中的loop函数。即当我们使用完了某个Message后，该Message被回收到废弃消息链。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">loop</span>() {  
    Looper me = myLooper();  
    MessageQueue queue = me.mQueue;  
    <span class="keyword">while</span> (<span class="keyword">true</span>) {  
        Message msg = queue.next(); <span class="comment">// might block  </span>
        <span class="keyword">if</span> (msg != <span class="keyword">null</span>) {  
            <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) {  
                <span class="comment">// No target is a magic identifier for the quit message.  </span>
                <span class="keyword">return</span>;  
            }  
            msg.target.dispatchMessage(msg);  
            msg.recycle();  
        }  
    }  
}
</pre></td></tr></table></figure>

<h3 id="sendToTarget()函数">sendToTarget()函数</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendToTarget</span>() {
    target.sendMessage(<span class="keyword">this</span>);
}
</pre></td></tr></table></figure>

<p>该函数比较简单，就是通过Message内部引用的Handler将消息发送出去。</p>
<h2 id="Handler源码分析">Handler源码分析</h2>
<h3 id="成员变量-1">成员变量</h3>
<p>我们先看一下它的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">final</span> MessageQueue mQueue;
<span class="keyword">final</span> Looper mLooper;
<span class="keyword">final</span> Callback mCallback;
</pre></td></tr></table></figure>

<p><strong>Handler作为一个管理者，其重要做用就是创建并发送消息，最后再处理消息。</strong><br>发送消息即为把指定的Message放入到消息队列中，等到合适的时机，消息泵从消息队列中抽取消息，再分发下去，进行处理。<br>因此，在Handler中，有必要维护当前线程的MessageQueue和Looper的引用。对于一个线程来说，MessageQueue和Looper都是唯一的，而多个handler是可以共享同一个线程的MessageQueue和Looper的引用。<br>Handler里面有以下几类核心函数共同完成上面的功能。</p>
<ul>
<li>构造函数</li>
<li>创建消息函数</li>
<li>发送消息函数</li>
<li>移除消息函数</li>
<li>消息分发及处理函数</li>
</ul>
<h3 id="构造函数">构造函数</h3>
<p>构造函数主要是对成员变量进行初始化，获取线程中的Looper、MessageQueue等对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="javadoc">/**
 * Default constructor associates this handler with the queue for the
 * current thread.
 *
 * If there isn't one, this handler won't be able to receive messages.
 */</span>
<span class="keyword">public</span> <span class="title">Handler</span>() {
    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) {
        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();
        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&
                (klass.getModifiers() & Modifier.STATIC) == <span class="number">0</span>) {
            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +
                klass.getCanonicalName());
        }
    }

    mLooper = Looper.myLooper();
    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(
            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);
    }
    mQueue = mLooper.mQueue;
    mCallback = <span class="keyword">null</span>;
}
</pre></td></tr></table></figure>

<p>默认构造函数通过<code>Looper.myLooper()</code>函数<strong>从当前线程中获取Looper对象</strong>，如果Looper对象不存在，那么Handler构造就<strong>失败了，会抛出RuntimeException</strong>，而MessageQueue是由Looper对象创建出来的，因此，mQueue直接便能从Looper中获取。对于UI线程，在程序初始化时，实际上looper对象就已被创建出来（通过调用Looper.prepare()进行创建，并把looper对象存放到一个静态的sThreadLocal中），因此，正常情况下，当我们new出来的Handler不指明任何参数时，实际上就是会默认关联到UI线程。但是，但如果该对象是在某个线程的Run方法中被创建出来，那么它会被关联到该后台线程。“关联到该线程”的意思实际上就是，当Handler关联到UI线程，那最终发送的消息是加到了UI线程的消息队列，如果它关联到后台线程，则发送的消息加到了后台线程的消息队列。下面的这种方式，mHandler会被直接关联到指定的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        Looper.prepare();
        
        Handler mHandler = <span class="keyword">new</span> Handler() {
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span>(Message msg) {
                <span class="comment">// process incoming messages here</span>
            }
        };

        Looper.loop();
    }
});
</pre></td></tr></table></figure>

<h3 id="创建消息函数：obtainMessage()及其系列函数">创建消息函数：obtainMessage()及其系列函数</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span>(<span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, Object obj) {
    <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>, what, arg1, arg2, obj);
}
</pre></td></tr></table></figure>

<p>这些函数都很简单，无非是通过Message.obtain(…)方法创建消息。obtain方法已在Message类中进行相关说明。还记得obtain方法的调用过程吗？忘记了的请回过头再看看。</p>
<h3 id="发送消息函数">发送消息函数</h3>
<p>发送的过程是由post其系列函数和send系列函数进行的。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>post(Runnable)
postAtTime(Runnable, <span class="keyword">long</span>)
postAtTime(Runnable, Object, <span class="keyword">long</span>)
postDelayed(Runnable, <span class="keyword">long</span>)
postAtFrontOfQueue(Runnable)
sendMessage(Message)
sendEmptyMessage(<span class="keyword">int</span>)
sendEmptyMessageDelayed(<span class="keyword">int</span>, <span class="keyword">long</span>)
sendEmptyMessageAtTime(<span class="keyword">int</span>, <span class="keyword">long</span>)
sendMessageDelayed(Message, <span class="keyword">long</span>)
sendMessageAtTime(Message, <span class="keyword">long</span>)
sendMessageAtFrontOfQueue(Message)
</pre></td></tr></table></figure>

<p>先说sendXXXMessage系列函数，这些函数提供了很多可选接口，主要是可使用delayMillis。如sendMessageDelayed(Message msg, long delayMillis)，<strong>该函数并不是说把消息延迟xxx毫秒后发送，而是延迟将消息分发下来</strong>。即消息加入消息队列后，message会隔xxx毫秒后从消息队列中被取出来执行。<br>这些函数最终都是调用的sendMessageAtTime函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span>(Message msg, <span class="keyword">long</span> uptimeMillis) {
    <span class="keyword">boolean</span> sent = <span class="keyword">false</span>;
    MessageQueue queue = mQueue;
    <span class="keyword">if</span> (queue != <span class="keyword">null</span>) {
        msg.target = <span class="keyword">this</span>;
        sent = queue.enqueueMessage(msg, uptimeMillis);
    } <span class="keyword">else</span> {
        RuntimeException e = <span class="keyword">new</span> RuntimeException(
            <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);
        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);
    }
    <span class="keyword">return</span> sent;
}
</pre></td></tr></table></figure>

<p>该方法就是调用MessageQueue的enqueueMessage(…)方法将指定的Message插入到消息队列中去，即加入Message链，并指明何时应该从消息队列中取出来执行。其中uptimeMillis就是绝对时间戳，uptimeMillis = current time + delayMillis。<br>postXXX系列函数来说，需要指定一个Runnable对象，在合适的时间执行。<br>实际上，他们最终调用的还是sendMessageAtTime函数，只不过中间多了一步，即根据Runnable创建Message对象。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span>(Runnable r, <span class="keyword">long</span> uptimeMillis) {
   <span class="keyword">return</span>  sendMessageAtTime(getPostMessage(r), uptimeMillis);
}
</pre></td></tr></table></figure>

<p>其中，getPostMessage代码如下：就是通过obtain方法获取一个Message，并设置其callback。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">private</span> <span class="keyword">final</span> Message <span class="title">getPostMessage</span>(Runnable r) {
    Message m = Message.obtain();
    m.callback = r;
    <span class="keyword">return</span> m;
}
</pre></td></tr></table></figure>

<h3 id="移除消息系列函数">移除消息系列函数</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>removeCallbacks(Runnable)
removeCallbacks(Runnable, Object)
removeCallbacksAndMessages(Object)
removeMessages(<span class="keyword">int</span>)
removeMessages(<span class="keyword">int</span>, Object)
</pre></td></tr></table></figure>

<p>这些函数的作用就是从当前消息队列中移除掉所有指定ID或指定Runnable对象的Message。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeCallbacks</span>(Runnable r) {
    mQueue.removeMessages(<span class="keyword">this</span>, r, <span class="keyword">null</span>);
}
</pre></td></tr></table></figure>

<p><strong>上面的所有函数完成了第一个功能，即消息的发送，并加入到消息队列中去。<br>但发送完后，并不是立即就能执行，当消息从消息泵中被取出来后，才行执行。因此，消息的发送和处理实际上是一个异步的过程。</strong></p>
<h3 id="消息分发及处理函数">消息分发及处理函数</h3>
<p>当消息从消息泵中抽取出来后，就会进行消息的分发。<br>消息抽取的过程需要参见Looper的核心处理函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">loop</span>() {
    Looper me = myLooper();
    MessageQueue queue = me.mQueue;
    <span class="keyword">while</span> (<span class="keyword">true</span>) {
        Message msg = queue.next(); <span class="comment">// might block</span>
        <span class="keyword">if</span> (msg != <span class="keyword">null</span>) {
            <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) {
                <span class="comment">// No target is a magic identifier for the quit message.</span>
                <span class="keyword">return</span>;
            }
            msg.target.dispatchMessage(msg);
            msg.recycle();
        }
    }
}
</pre></td></tr></table></figure>

<p>从上面可以看出，loop函数本身就是一个回路（死循环），不停的调用queue.next()函数从消息链中取出消息（如果取不到消息就会被阻塞住）。然后通过MSG的target成员变量（Handler）来调用其dispatchMessage方法将消息分发下去，然后执行消息处理函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span>(Message msg) {
    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) {
        handleCallback(msg);
    } <span class="keyword">else</span> {
        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) {
            <span class="keyword">if</span> (mCallback.handleMessage(msg)) {
                <span class="keyword">return</span>;
            }
        }
        handleMessage(msg);
    }
}
</pre></td></tr></table></figure>

<p>在消息的分发的过程中，其执行是有<strong>优先级</strong>的：</p>
<ul>
<li>如果Message中包含callback（即通过post系列函数设置的Runnable对象），那么它会被优先执行。</li>
<li>否则，如果给当前的Handler设置了mCallback，那么它会优先执行。如果该方法返回true，分发结束，处理完毕。如果返回false，那么他还有机会执行默认的handleMessage函数。</li>
</ul>
<p>以下是三种情况的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="number">1.</span> 
    Handler mHandler = <span class="keyword">new</span> Handler();
    mHandler.post(<span class="keyword">new</span> Runnable() {
        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
            <span class="comment">// TODO something</span>
        }
    });
<span class="number">2.</span> 
    Handler mHandler = <span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback() {
        
        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span>(Message msg) {
            <span class="comment">// TODO something</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }
    });
<span class="number">3.</span> 
    <span class="keyword">protected</span> Handler m_handler = <span class="keyword">new</span> Handler() {
        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span>(Message msg) {
            <span class="comment">// TODO something</span>
        }
    });
</pre></td></tr></table></figure>

<h2 id="MessageQueue源码分析">MessageQueue源码分析</h2>
<h3 id="成员变量-2">成员变量</h3>
<p>我们先看一下它的成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>Message mMessages;
<span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="keyword">new</span> ArrayList&lt;IdleHandler&gt;();
<span class="keyword">private</span> IdleHandler[] mPendingIdleHandlers;
<span class="keyword">private</span> <span class="keyword">boolean</span> mQuiting;
<span class="keyword">boolean</span> mQuitAllowed = <span class="keyword">true</span>;
<span class="comment">// Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.</span>
<span class="keyword">private</span> <span class="keyword">boolean</span> mBlocked;
</pre></td></tr></table></figure>

<p><strong>mMessages：</strong>在最初不了解Message类时，以为MessageQueue里面，存放的是一个类似于LinkedList<message>的数据结构。当了解Message数据结构后，才知道MessageQueue里面维护的只有一个Message，因为Message本身就能构建一个Message链。MessageQueue主要功能就是维护这个Message链，如插入和删除Message链中的元素，并提供获取Message链中next  Message的方法。这里，mMessages始终指向的是消息链的第一个节点，即头节点。<br><strong>mIdleHandlers：</strong>外部注册的回调列表（listeners）。如果当前消息队列已没有新的Message能被取出来时，线程即将被阻塞前被调用。即线程处于空闲时间时，被调用。<br><strong>mPendingIdleHandlers：</strong>该成员变量配合上面的mIdleHandlers使用，我觉得它没有必要保存起来，完全用一个临时变量即可。<br><strong>mQuiting：</strong>当前消息队列是否已准备退出。实际上，如果它为True，也就表明当前线程将会立马结束掉。<br><strong>mQuitAllowed：</strong>是否允许退出消息队列。对于主线程（UI线程），该标志量为true。<br><strong>mBlocked：</strong>标志当前消息队列是否处于阻塞状态。<br>下面的接口定义了线程处于空闲状态时的回调函数。由此可以看出，当你想在线程不忙的时候干点其它事情的话，这个接口就能派得上用场了。</message></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">IdleHandler</span> {</span>
    <span class="keyword">boolean</span> queueIdle();
}
</pre></td></tr></table></figure>

<p>以下方法用来注册和移除线程处于空闲状态时的回调函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addIdleHandler</span>(IdleHandler handler) {
    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Can't add a null IdleHandler"</span>);
    }
    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
        mIdleHandlers.add(handler);
    }
}

<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeIdleHandler</span>(IdleHandler handler) {
    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
        mIdleHandlers.remove(handler);
    }
}
</pre></td></tr></table></figure>

<p>再来看一看MessageQueue的两个核心函数：enqueueMessage(…)与next()函数。</p>
<h3 id="enqueueMessage(Message_msg,_long_when)函数">enqueueMessage(Message msg, long when)函数</h3>
<p>该函数的目的就是把指定的Message按照绝对时间插入到当前的消息队列中去。还记得该函数是在哪里被调用的吗？请回过头看看Handler的源代码：sendMessageAtTime(Message msg, long uptimeMillis)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre></td><td class="code"><pre><span class="keyword">final</span> <span class="keyword">boolean</span> enqueueMessage(Message msg, <span class="keyword">long</span> when) {
    <span class="comment">// 1. 如果MSG的绝对时间戳不为0（说明已被初始化，并已加入到队列中），抛出异常</span>
    <span class="keyword">if</span> (msg.when != <span class="number">0</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(msg
                + <span class="string">" This message is already in use."</span>);
    }
    
    <span class="comment">// 2. 如果MSG的target为null，说明该消息是QUIT消息。如果此时又发现mQuitAllowed为false，则抛出异常。</span>
    <span class="comment">// 实际上，如果你调用主线程的Looper.quit()方法，你会发现该异常会被抛出来。因为主线程的消息循环是不允许退出的。</span>
    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span> && !mQuitAllowed) {
        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread not allowed to quit"</span>);
    }
    <span class="keyword">final</span> <span class="keyword">boolean</span> needWake;
    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
        <span class="comment">// 3. 如果消息队列正在退出，则直接返回false；否则，查看当前要加入的MSG是否是要求退出消息队列的MSG</span>
        <span class="comment">//（QUIT MSG：判断依据是MSG的target是否为空），如果是，则将mQuiting设置为true，然后把该消息加入到消息</span>
        <span class="comment">// 队列的头部，以保证下一次通过next()函数取出的消息就是QUIT消息，能快速的终止掉线程。</span>
        <span class="keyword">if</span> (mQuiting) {
            RuntimeException e = <span class="keyword">new</span> RuntimeException(
                msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);
            Log.w(<span class="string">"MessageQueue"</span>, e.getMessage(), e);
            <span class="keyword">return</span> <span class="keyword">false</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) {
            mQuiting = <span class="keyword">true</span>;
        }
        
        <span class="comment">// 4. MSG最终从消息队列中取出来的绝对时间戳。NOTE：MSG的when字段只有在这一个地方被主动设置过。</span>
        msg.when = when;
        <span class="comment">//Log.d("MessageQueue", "Enqueing: " + msg);</span>

        <span class="comment">// NOTE：以下部分就是真正如何将消息插入消息链的过程。</span>
        Message p = mMessages;
        <span class="comment">// 5. 如果当前的消息链为空，或者要插入的MSG为QUIT消息，或者要插入的MSG时间小于消息链的第一个消息。</span>
        <span class="comment">// 那么，强势插入到消息链的头部。显示，消息链的头部被改变了，变成了新添加的消息。needWake需要根据</span>
        <span class="comment">// mBlocked的情况考虑是否触发。</span>
        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) {
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked; <span class="comment">// new head, might need to wake up</span>
        } <span class="keyword">else</span> {
            <span class="comment">//  6. 否则，我们需要遍历该消息链，将该MSG插入到合适的位置。整个消息链是按消息被取出的绝对时间戳</span>
            <span class="comment">// 由小到大链接起来的。时间轴为：msg1.when &lt;= msg2.when &lt;= msg3.when &lt;= msg4.when &lt;= msg5.when……</span>
            Message prev = <span class="keyword">null</span>;
            <span class="keyword">while</span> (p != <span class="keyword">null</span> && p.when &lt;= when) {
                prev = p;
                p = p.next;
            }
            msg.next = prev.next;
            prev.next = msg;
            needWake = <span class="keyword">false</span>; <span class="comment">// still waiting on head, no need to wake up</span>
        }
    }

    <span class="comment">// 7. 对于needWake，如果该变量为true，说明mBlocked为true，即当前线程处于阻塞状，也即nativePollOnce处于阻塞状态。但此时，</span>
    <span class="comment">// 我们已通过这个enqueueMessage方法已经向消息链中添加了一个消息，也就是说，此时我们需要把阻塞状态变成非阻塞状态，</span>
    <span class="comment">// 让next()函数能够取到MSG。怎么办？通过执行nativeWake方法，便能触发nativePollOnce函数结束等待。实际上，</span>
    <span class="comment">// nativePollOnce和nativeWake内部是通过管道的机制来实现阻塞和接触阻塞的。我的理解是： nativePollOnce函数从管道中</span>
    <span class="comment">// 读数据，如果发现管道中有数据，则立即返回，否则，一直等待。而nativeWake就是向管道中写数据，只要往管道的另一端写数据，</span>
    <span class="comment">// 则nativePollOnce就能立马从管道中读出数据来，从而变成非阻塞状态。（请参考：http://book.51cto.com/art/201208/353352.htm）</span>
    <span class="keyword">if</span> (needWake) {
        nativeWake(mPtr);
    }
    <span class="keyword">return</span> <span class="keyword">true</span>;
}
</pre></td></tr></table></figure>

<h3 id="next()函数">next()函数</h3>
<p>我们先提前一步看看Looper.loop()函数（里面省掉了若干无用代码）。<br>该函数就是从消息队列中取出消息，然后把这个取出来的消息扔给Looper，Looper根据消息进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">loop</span>() {
    Looper me = myLooper();
    MessageQueue queue = me.mQueue;
    <span class="keyword">while</span> (<span class="keyword">true</span>) {
        Message msg = queue.next(); <span class="comment">// might block</span>
        <span class="keyword">if</span> (msg != <span class="keyword">null</span>) {
            <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) {
                <span class="comment">// No target is a magic identifier for the quit message.</span>
                <span class="keyword">return</span>;
            }
            msg.target.dispatchMessage(msg);
            msg.recycle();
        }
    }
}
</pre></td></tr></table></figure>

<p>从上面的代码来看，loop函数本身就是一个回路（死循环），不停的调用<code>queue.next()</code>函数从消息链中取出消息（如果取不到消息就会被阻塞住）。然后通过MSG的target成员变量（Handler）来调用其<code>dispatchMessage</code>方法将消息分发下去，然后执行消息处理函数。如果取出来的消息的target为null，那么说明该消息是退出消息，则Looper退出，线程即将结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
</pre></td><td class="code"><pre><span class="keyword">final</span> Message next() {
    <span class="comment">// 1. 取MSG前，先初始化状态</span>
    <span class="comment">// a) pendingIdleHandlerCount为-1时，说明是第一次循环，在当前没有消息队列中没有MSG的情况下，需要处理注册的Handler。</span>
    <span class="comment">// b) nextPollTimeoutMillis 超时时间。即等待xxx毫秒后，该函数返回。如果值为0，则无须等待立即返回。如果为-1，则进入无限等待，直到有事件发生为止。</span>
    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span>
    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;

    <span class="keyword">for</span> (;;) {
           <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) {
             <span class="javadoc">/** 该函数作用暂时没有研究，拷贝基注释供参考
               * Flush any Binder commands pending in the current thread to the kernel
               * driver.  This can be useful to call before performing an operation that may block for a long
               * time, to ensure that any pending object references have been released
               * in order to prevent the process from holding on to objects longer than
               * it needs to.
               */</span>
                Binder.flushPendingCommands();
             }
           
            <span class="comment">// 该函数提供阻塞操作。如果nextPollTimeoutMillis为0，则该函数无须等待，立即返回。如果为-1，则进入无限等待，</span>
            <span class="comment">// 直到有事件发生为止。在第一次时，由于nextPollTimeoutMillis被初始化为0，所以该函数会立即返回，然后从消息链的头部获取消息。</span>
            nativePollOnce(mPtr, nextPollTimeoutMillis);
            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
                <span class="comment">// Try to retrieve the next message.  Return if found.</span>
                <span class="comment">// 2. 获取消息链的头节点。</span>
                <span class="comment">// 2.1 如果头节点不为空，需要判断头节点所代表的MSG执行的时间是否小于当前时间，如果小于，则该MSG应该被扔出去，</span>
                <span class="comment">//     让loop()函数执行其分发过程。否则，需要让线程再次等待(when–now)毫秒。</span>
                <span class="comment">// 2.2 如果头节点为空，显然，消息链中无消息可能，我们需要设置nextPollTimeoutMillis为-1，让线程阻塞住，</span>
                <span class="comment">//      直到有消息投递（调用enqueueMessage方法），并利用nativeWake方法解除阻塞。</span>
                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();
                <span class="keyword">final</span> Message msg = mMessages;
                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) {
                    <span class="keyword">final</span> <span class="keyword">long</span> when = msg.when;
                    <span class="keyword">if</span> (now &gt;= when) {
                        mBlocked = <span class="keyword">false</span>;
                        mMessages = msg.next;
                        msg.next = <span class="keyword">null</span>;
                        <span class="keyword">if</span> (Config.LOGV) Log.v(<span class="string">"MessageQueue"</span>, <span class="string">"Returning message: "</span> + msg);
                        <span class="keyword">return</span> msg;
                    } <span class="keyword">else</span> {
                        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(when - now, Integer.MAX_VALUE);
                    }
                } <span class="keyword">else</span> {
                    nextPollTimeoutMillis = -<span class="number">1</span>;
                }
                <span class="comment">// 3. 如果走到这一步，说明当前无消息可用，或者当前的消息还需要等待一段时间才能够分发下去。</span>
                <span class="comment">// 所以，在这段时间之类，我们有时间告诉listeners，当前线程空闲了，给你们一个机会干点其它事情。比如说垃圾回收。</span>
                <span class="comment">// If first time, then get the number of idlers to run.</span>
                <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span>) {
                    pendingIdleHandlerCount = mIdleHandlers.size();
                }
                <span class="keyword">if</span> (pendingIdleHandlerCount == <span class="number">0</span>) {
                    <span class="comment">// No idle handlers to run.  Loop and wait some more.</span>
                    mBlocked = <span class="keyword">true</span>;
                    <span class="keyword">continue</span>;
                }
                <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) {
                    mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];
                }
                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
            }
            
            <span class="comment">// 4. 通知listeners，执行其它事情。</span>
            <span class="comment">// Run the idle handlers.</span>
            <span class="comment">// We only ever reach this code block during the first iteration.</span>
            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) {
                <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];
                mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span>
                <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;
                <span class="keyword">try</span> {
                    <span class="comment">// 如果该函数返回false，表明这个函数只想执行一次，我们应该把它从列表中删除。如果返回true，则表示下次空闲时，会再次执行。</span>
                    keep = idler.queueIdle();
                } <span class="keyword">catch</span> (Throwable t) {
                    Log.wtf(<span class="string">"MessageQueue"</span>, <span class="string">"IdleHandler threw exception"</span>, t);
                }
                <span class="keyword">if</span> (!keep) {
                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
                        mIdleHandlers.remove(idler);
                    }
                }
            }
            <span class="comment">// 5. 重置状态</span>
            <span class="comment">// pendingIdleHandlerCount重置为0，是为了避免第二次循环时，再一次通知listeners，也就说是，如果想剩余的listeners再次被调用，</span>
            <span class="comment">// 那么只有等到下一次调用next()函数了。</span>
            <span class="comment">// nextPollTimeoutMillis重置为0，是为了避免在循环执行idler.queueIdle()时，有消息投递。所以重置它后，第二次循环在执行nativePollOnce时，</span>
            <span class="comment">// 会立即返回，然后再走其它逻辑。此时，如果还是消息链中还是没有消息，那么将会在continue;处执行完第二次循环，进行第三次循环，然后进入无限等待状态。</span>
            <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span>
            pendingIdleHandlerCount = <span class="number">0</span>;
            <span class="comment">// While calling an idle handler, a new message could have been delivered</span>
            <span class="comment">// so go back and look again for a pending message without waiting.</span>
            nextPollTimeoutMillis = <span class="number">0</span>;
        }
    }
}
</pre></td></tr></table></figure>

<p>从上面的代码来看，next()函数主要有三个作用：</p>
<ul>
<li>如果消息链中有合适的消息，直接将MSG扔出去。</li>
<li>如果没有，在消息循环进入阻塞状态。通过nativePollOnce进行阻塞。</li>
<li>在阻塞前，会通过外界（用户）注册的IdleHandler接口通知外界（用户），线程即将处于block状态，外界可以处理一些其它的事情。如说垃圾回收。</li>
</ul>
<p>在看这个函数时，最开始觉得这里的逻辑有点困惑，特别是<code>for(;;)</code>和<code>IdleHandler</code>调用的过程。看上去，这里的for(;;)看上去是是个死循环，但<strong>实际上，每调用一次next()函数，这个循环最多只会被执行三次。</strong><br><strong>第一次循环</strong>，正如上面的功能1，如果消息链中有合适的消息，直接将MSG扔出去。<br>如果没有，则会通知各listeners，线程空闲了。执行完后，为了避免在listners执行的过程中，有消息投递，那么此时重置nextPollTimeoutMillis，然后进行<strong>第二次循环</strong>，由于此时nextPollTimeoutMillis为0，则nativePollOnce不会阻塞，立即返回，取MSG，如果此时消息链中还是没有MSG，则会在将会在continue处结束第二次循环，此时nextPollTimeoutMillis已被设置为-1，最终，<strong>第三次循环</strong>时，nativePollOnce发现nextPollTimeoutMillis为-1，则进入无限等待状态，直到有新的MSG被投递到队列中来。当有新的MSG后，由于enqueueMessage中调用了nativeWake函数，nativePollOnce会从等待中恢复回来并返回，继续执行，然后将新的MSG扔出去，for循环结束。三次循环结束。<br>至于<code>nativePollOnce</code>函数是如何进行阻塞的，可以参考：<a href="http://book.51cto.com/art/201208/353352.htm" target="_blank" rel="external">http://book.51cto.com/art/201208/353352.htm</a></p>
<h3 id="删除函数">删除函数</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">final</span> <span class="keyword">boolean</span> removeMessages(Handler h, <span class="keyword">int</span> what, Objectobject, <span class="keyword">boolean</span> doRemove);
<span class="keyword">final</span> <span class="keyword">void</span> removeMessages(Handler h,Runnable r, Object object)
<span class="keyword">final</span> voidremoveCallbacksAndMessages(Handler h, Object object)
</pre></td></tr></table></figure>

<p>其内部运作基本一样，我们只需要搞明白一个即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="keyword">final</span> <span class="keyword">boolean</span> removeMessages(Handler h, <span class="keyword">int</span> what, Object object, <span class="keyword">boolean</span> doRemove) {
    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
        Message p = mMessages;
        <span class="keyword">boolean</span> found = <span class="keyword">false</span>;
        <span class="comment">// 以下两个过程均是简单的链表操作。看不懂的得要复习下数据结构第二章了。</span>
        <span class="comment">// Remove all messages at front.</span>
        <span class="comment">// 如果消息链的头节点就是所要找的MSG，则把该MSG从链表中断开，并把断开的节点加入废弃消息链中。</span>
        <span class="comment">// 然后头节点往下移动，直到头结点不为指定MSG为止。</span>
        <span class="keyword">while</span> (p != <span class="keyword">null</span> && p.target == h && p.what == what
               && (object == <span class="keyword">null</span> || p.obj == object)) {
            <span class="keyword">if</span> (!doRemove) <span class="keyword">return</span> <span class="keyword">true</span>;
            found = <span class="keyword">true</span>;
            Message n = p.next;
            mMessages = n;
            p.recycle();
            p = n;
        }
        <span class="comment">// Remove all messages after front.</span>
        <span class="comment">// 如果消息链的头节点不是所要找的MSG，则通过辅助变量n，往下查找指定MSG，找到了，则把该MSG从链表中断开，</span>
        <span class="comment">// 并把断开的节点加入废弃消息链中。然后辅助变量n往下移动，直到链表尾部。</span>
        <span class="keyword">while</span> (p != <span class="keyword">null</span>) {
            Message n = p.next;
            <span class="keyword">if</span> (n != <span class="keyword">null</span>) {
                <span class="keyword">if</span> (n.target == h && n.what == what
                    && (object == <span class="keyword">null</span> || n.obj == object)) {
                    <span class="keyword">if</span> (!doRemove) <span class="keyword">return</span> <span class="keyword">true</span>;
                    found = <span class="keyword">true</span>;
                    Message nn = n.next;
                    n.recycle();
                    p.next = nn;
                    <span class="keyword">continue</span>;
                }
            }
            p = n;
        }
        
        <span class="keyword">return</span> found;
    }
}
</pre></td></tr></table></figure>

<p>该函数有三个作用：</p>
<ul>
<li>查找功能：如果doRemove为false，则该函数中是从消息链中查找是否有对应的消息。有则返回true，否则返回false</li>
<li>删除功能：从消息链中找到所有的同ID、同target、同object的消息，并把它从当前的消息链中断开。</li>
<li>构建Message Pool：构建废弃消息链（池）。还记得Message的recycle()方法吗？该方法就会把当前的消息废弃掉，加入到废弃消息链中，以供废品再利用。</li>
</ul>
<h2 id="Looper源码分析">Looper源码分析</h2>
<p>Looper的主要功能是管理MessageQueue，不停的从MessageQueue里面抽取消息，然后分发下去，周而复始，直到抽取到的消息是退出消息，Looper结束，线程即将退出。<br>Looper有以下几点需要注意：</p>
<ul>
<li>一个线程只能有一个Looper对象。</li>
<li>一个Looper对象只能有一个MessageQueue</li>
</ul>
<p>我们先看一下它的重要成员变量及初始化函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">final</span> MessageQueue mQueue;
<span class="keyword">volatile</span> <span class="keyword">boolean</span> mRun;
Thread mThread;

<span class="keyword">private</span> <span class="title">Looper</span>() {
    mQueue = <span class="keyword">new</span> MessageQueue();
    mRun = <span class="keyword">true</span>;
    mThread = Thread.currentThread();
}
</pre></td></tr></table></figure>

<p>显然，在创建一个Looper时，它就会顺便创建一个消息队列，初始化mRun，并关联到当然线程。由于构造函数是私有的，那如何创建Looper对象？通过prepare()函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepare</span>() {
    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);
    }
    sThreadLocal.set(<span class="keyword">new</span> Looper());
}
</pre></td></tr></table></figure>

<p>对于每个线程来说，sThreadLocal存放着Looper的唯一实例，多次调用会直接导致异常。所以，一个线程只能调用一次prepare()函数。<br>另外，在该类中，维护了一个主线程的Looper对象，并提供了一系列方法可以访问它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">private</span> <span class="keyword">static</span> Looper mMainLooper = <span class="keyword">null</span>;
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span>()
<span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setMainLooper</span>(Looper looper)
<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">final</span> Looper <span class="title">getMainLooper</span>()
</pre></td></tr></table></figure>

<p>顺便贴出主线程Looper对象生成的源代码：<br>frameworks/base/core/java/android/app/ActivityThread.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
    ……
    Looper.prepareMainLooper();

    ActivityThread thread = <span class="keyword">new</span> ActivityThread();
    thread.attach(<span class="keyword">false</span>);

    Looper.loop();

    ……
}
</pre></td></tr></table></figure>

<p>对于Looper类来说，最重要的莫过于loop()函数，不过该函数已被重复提过几次，这里不再重复描述了。<br>另外，再一个重要函数是quit()，它通过向消息队列中插入一条QUIT Message来退出Looper循环，从而达到退出线程的目的。其中，Quit Message的标志就是该Message的target为null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span>() {
    Message msg = Message.obtain();
    <span class="comment">// NOTE: By enqueueing directly into the message queue, the</span>
    <span class="comment">// message is left with a null target.  This is how we know it is</span>
    <span class="comment">// a quit message.</span>
    mQueue.enqueueMessage(msg, <span class="number">0</span>);
}
</pre></td></tr></table></figure>




      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/Android/">Android</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/Android/">Android</a>, <a href="/tags/消息循环/">消息循环</a>, <a href="/tags/Message/">Message</a>, <a href="/tags/Handler/">Handler</a>, <a href="/tags/MessageQueue/">MessageQueue</a>, <a href="/tags/Looper/">Looper</a>
  </div>

        <div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a><a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a><a href="#" class="bds_sdo" data-cmd="sdo" title="分享到麦库记事"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">Comments</h1>
<!-- 
  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="http://yoursite.com/2012/11/13/源码浅析-Message-Handler-MessageQueue-Looper/" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
 -->

  <!-- Duoshuo Comment BEGIN -->
  <div class="ds-thread"></div>
  <script type="text/javascript">
  var duoshuoQuery = {short_name:"woyaowenzi"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = 'http://static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] 
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
  <!-- Duoshuo Comment END -->

</section>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Categories</h3>
  <ul class="entry">
  
    <li><a href="/categories/Android/">Android</a><small>8</small></li>
  
    <li><a href="/categories/Android/iOS/Windows/Linux/C++/">C++</a><small>1</small></li>
  
    <li><a href="/categories/Eclipse/">Eclipse</a><small>3</small></li>
  
    <li><a href="/categories/Android/iOS/Windows/Linux/C++/JAVA/">JAVA</a><small>1</small></li>
  
    <li><a href="/categories/Android/iOS/Windows/Linux/">Linux</a><small>1</small></li>
  
    <li><a href="/categories/MacOS/">MacOS</a><small>1</small></li>
  
    <li><a href="/categories/SublimeText/">SublimeText</a><small>1</small></li>
  
    <li><a href="/categories/Android/iOS/Windows/">Windows</a><small>1</small></li>
  
    <li><a href="/categories/Android/iOS/">iOS</a><small>1</small></li>
  
    <li><a href="/categories/tools/">tools</a><small>1</small></li>
  
    <li><a href="/categories/设计/">设计</a><small>1</small></li>
  
    <li><a href="/categories/设计模式/">设计模式</a><small>8</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/Android/">Android</a><small>7</small></li>
  
    <li><a href="/tags/CodeReview/">CodeReview</a><small>1</small></li>
  
    <li><a href="/tags/CodingRuler/">CodingRuler</a><small>1</small></li>
  
    <li><a href="/tags/Cookie/">Cookie</a><small>1</small></li>
  
    <li><a href="/tags/Eclipse，效率/">Eclipse，效率</a><small>3</small></li>
  
    <li><a href="/tags/Handler/">Handler</a><small>1</small></li>
  
    <li><a href="/tags/Looper/">Looper</a><small>1</small></li>
  
    <li><a href="/tags/Message/">Message</a><small>1</small></li>
  
    <li><a href="/tags/MessageQueue/">MessageQueue</a><small>1</small></li>
  
    <li><a href="/tags/Network/">Network</a><small>1</small></li>
  
    <li><a href="/tags/SDK，设计/">SDK，设计</a><small>1</small></li>
  
    <li><a href="/tags/Service保活/">Service保活</a><small>1</small></li>
  
    <li><a href="/tags/SublimeText，效率/">SublimeText，效率</a><small>1</small></li>
  
    <li><a href="/tags/Tools/">Tools</a><small>1</small></li>
  
    <li><a href="/tags/URI-Scheme/">URI Scheme</a><small>1</small></li>
  
    <li><a href="/tags/VIM，效率/">VIM，效率</a><small>1</small></li>
  
    <li><a href="/tags/iOS/">iOS</a><small>1</small></li>
  
    <li><a href="/tags/tools/">tools</a><small>5</small></li>
  
    <li><a href="/tags/异常，设计/">异常，设计</a><small>1</small></li>
  
    <li><a href="/tags/性能优化/">性能优化</a><small>1</small></li>
  
    <li><a href="/tags/抓包/">抓包</a><small>1</small></li>
  
    <li><a href="/tags/消息循环/">消息循环</a><small>1</small></li>
  
    <li><a href="/tags/设计模式/">设计模式</a><small>1</small></li>
  
    <li><a href="/tags/设计模式，Builder/">设计模式，Builder</a><small>1</small></li>
  
    <li><a href="/tags/设计模式，单例/">设计模式，单例</a><small>1</small></li>
  
    <li><a href="/tags/设计模式，工厂方法/">设计模式，工厂方法</a><small>1</small></li>
  
    <li><a href="/tags/设计模式，简单工厂/">设计模式，简单工厂</a><small>1</small></li>
  
    <li><a href="/tags/设计模式，组合/">设计模式，组合</a><small>1</small></li>
  
    <li><a href="/tags/设计模式，装饰模式/">设计模式，装饰模式</a><small>1</small></li>
  
    <li><a href="/tags/设计模式，观察者/">设计模式，观察者</a><small>1</small></li>
  
    <li><a href="/tags/设计模式，适配器/">设计模式，适配器</a><small>1</small></li>
  
  </ul>
</div>


  <div class="widget tag">
	<h3 class="title">友情链接</h3>
	<ul class="entry">
		<li>
			<a href="http://zipperary.com/" title="Zippera's Blog">Zippera</a>
		</li>
		<li>
			<a href="http://blog.csdn.net/leehong2005" title="leehong2005's Blog">leehong2005</a>
		</li>
		<li>
			<a href="http://blog.csdn.net/woyaowenzi" title="woyaowenzi's Blog">woyaowenzi</a>
		</li>
		<li>
			<a href="http://www.hongtaozhy.com/" title="hongtaozhy's Blog">hongtaozhy</a>
		</li>
		<li>
			<a href="http://huangliangjie.gitcafe.com/" title="huangliangjie's Blog">huangliangjie</a>
		</li>
	</ul>
</div>

  <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=1&ptype=1&speed=300&skin=5&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=1701266941&verifier=5c8d84f7&dpc=1"></iframe>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 LiuLin
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>